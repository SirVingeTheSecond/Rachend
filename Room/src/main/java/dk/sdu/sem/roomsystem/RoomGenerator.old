/**
 * This method creates a tilemap entity with animation data if present in the tileset.
 */
private Entity createTileMapEntity(RoomLayer layerDTO, String tileMapName, RoomTileset tilesetDTO) {
    // Create the tilemap entity
    Entity tilemapEntity = new Entity();
    tilemapEntity.addComponent(new TransformComponent(new Vector2D(0, 0), 0, new Vector2D(1, 1)));

    // Generate a map layout
    int[][] tileMap = getMapLayout(layerDTO);

    // Create tilemap data component
    TilemapComponent tilemapComponent = new TilemapComponent(
        tileMapName,  // The tileset ID used in Assets.createSpriteSheet()
        tileMap,      // Tile indices
        GameConstants.TILE_SIZE  // Tile size
    );
    tilemapEntity.addComponent(tilemapComponent);

    // Create tilemap renderer component
    TilemapRendererComponent rendererComponent = new TilemapRendererComponent(tilemapComponent);
    rendererComponent.setRenderLayer(renderLayer);
    tilemapEntity.addComponent(rendererComponent);

    // Parse and add animations from the tileset
    parseAnimatedTiles(tilemapEntity, tilemapComponent, tilesetDTO);

    // Update the collision map
    updateCollisionMap(tilesetDTO, tileMap);

    return tilemapEntity;
}

/**
 * Parses animated tiles from a Tiled tileset and adds them to the entity.
 * This method extracts animation data from the tileset and creates animation
 * components for the tilemap entity.
 *
 * @param tilemapEntity The entity to add animations to
 * @param tilemapComponent The tilemap component containing basic tile data
 * @param tileset The tileset containing animation data
 */
private void parseAnimatedTiles(Entity tilemapEntity, TilemapComponent tilemapComponent, RoomTileset tileset) {
    // Check if tileset has animation frames
    List<RoomTileset.Tile> tilesWithAnimations = tileset.tiles.stream()
        .filter(tile -> hasAnimationFrames(tile))
        .collect(Collectors.toList());

    if (tilesWithAnimations.isEmpty()) {
        return; // No animations in this tileset
    }

    // Create animation component if we have animations
    TileAnimationComponent animComponent = new TileAnimationComponent();
    boolean addedAnimations = false;

    // Process each animated tile
    for (RoomTileset.Tile tile : tilesWithAnimations) {
        List<TileAnimation.Frame> frames = extractAnimationFrames(tile);
        if (frames.isEmpty()) {
            continue;
        }

        // Create frame references and durations
        List<IAssetReference<Sprite>> frameRefs = new ArrayList<>();
        List<Float> frameDurations = new ArrayList<>();

        for (TileAnimation.Frame frame : frames) {
            // Get the sprite map for this tileset
            SpriteMap spriteMap = AssetFacade.preloadAsType(tilemapComponent.getTilesetId(), SpriteMap.class);
            if (spriteMap == null) {
                continue;
            }

            // Create a reference to the sprite in the sprite map
            IAssetReference<Sprite> spriteRef = AssetFacade.createSpriteMapTileReference(
                tilemapComponent.getTilesetId(), frame.tileId);

            frameRefs.add(spriteRef);
            // Convert milliseconds to seconds for frame duration
            frameDurations.add(frame.duration / 1000.0f);
        }

        // Add the animation if we have frames
        if (!frameRefs.isEmpty()) {
            TileAnimation animation = new TileAnimation(frameRefs, frameDurations, true);
            animComponent.addTileAnimation(tile.id, animation);
            addedAnimations = true;
        }
    }

    // Only add the component if we actually have animations
    if (addedAnimations) {
        tilemapEntity.addComponent(animComponent);
        if (DEBUG_ZONES) {
            System.out.println("Added " + animComponent.getAnimatedTileCount() +
                               " tile animations to tilemap with tileset: " +
                               tilemapComponent.getTilesetId());
        }
    }
}

/**
 * Checks if a tile has animation frames defined.
 *
 * @param tile The tile to check
 * @return True if the tile has animation frames, false otherwise
 */
private boolean hasAnimationFrames(RoomTileset.Tile tile) {
    // In Tiled format, animation frames are usually stored in a property called "animation"
    return tile.properties.stream()
        .anyMatch(p -> p.name.equals("animation") && p.value != null);
}

/**
 * Extracts animation frames from a tile.
 *
 * @param tile The tile containing animation data
 * @return List of animation frames
 */
private List<TileAnimation.Frame> extractAnimationFrames(RoomTileset.Tile tile) {
    List<TileAnimation.Frame> frames = new ArrayList<>();

    // Find the animation property
    for (RoomTileset.Tile.Property property : tile.properties) {
        if (property.name.equals("animation")) {
            // The actual format will depend on how Tiled exports the animation data
            // Common formats:
            // 1. JSON array: [{tileid: 1, duration: 100}, {tileid: 2, duration: 100}]
            // 2. String format: "1:100,2:100,3:100"

            // For this implementation, let's assume a simple string format
            // We'll need to adapt this based on the actual Tiled export format
            if (property.value instanceof String) {
                String animData = (String) property.value;
                frames.addAll(parseAnimationString(animData));
            }
            break;
        }
    }

    return frames;
}

/**
 * Parses animation data from a string format.
 * This method handles the string format "tileId:duration,tileId:duration"
 *
 * @param animData The animation data string
 * @return List of parsed animation frames
 */
private List<TileAnimation.Frame> parseAnimationString(String animData) {
    List<TileAnimation.Frame> frames = new ArrayList<>();

    String[] frameDefs = animData.split(",");
    for (String frameDef : frameDefs) {
        String[] parts = frameDef.trim().split(":");
        if (parts.length == 2) {
            try {
                int tileId = Integer.parseInt(parts[0]);
                int duration = Integer.parseInt(parts[1]);
                frames.add(new TileAnimation.Frame(tileId, duration));
            } catch (NumberFormatException e) {
                // Skip invalid frame definitions
                System.err.println("Invalid animation frame definition: " + frameDef);
            }
        }
    }

    return frames;
}